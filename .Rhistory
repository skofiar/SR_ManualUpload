)
})
# Name the nested elements (2nd level) of the list
names(type_list) <- unique_types
})
# Name the elements of the list (1st level)
names(triangle_list) <- unique_portfolios
triangle_list
unique_portfolios
triangle_list
# First convert the data columns "Origin Period", "Development Period", "Amount"
## to needed numeric form:
datamat[, "Amount"] <- round(as.numeric(datamat[, "Amount" ]), digits = 2)
unique_portfolios <- unique(datamat$`Portfolio Name`)
unique_types <- unique(datamat$`Type of Amount`)
datamat
triangle_list <- lapply(unique_portfolios, function(i) {
datamat_cur <- datamat[datamat$`Portfolio Name` == i,]  # Assuming datamat is now a data.table
type_list <- lapply(unique_types, function(j) {
datamat_type <- datamat_cur[datamat_cur$`Type of Amount` == j,]
as.triangle(
as.data.frame(datamat_type),
origin = "Origin Period", dev = "Development Period", value = "Amount"
)
})
# Name the nested elements (2nd level) of the list
names(type_list) <- unique_types
})
View(triangle_list)
# First convert the data columns "Origin Period", "Development Period", "Amount"
## to needed numeric form:
datamat[, "Amount"] <- round(as.numeric(datamat[, "Amount" ]), digits = 2)
unique_portofilios <- unique(datamat$`Portfolio Name`)
unique_types <- unique(datamat$`Type of Amount`)
triangle_list <- lapply(unique_portofilios, function(i) {
datamat_cur <- datamat[datamat$`Portfolio Name` == i,]  # Assuming datamat is now a data.table
type_list <- lapply(unique_types, function(j) {
datamat_type <- datamat_cur[datamat_cur$`Type of Amount` == j,]
as.triangle(
as.data.frame(datamat_type),
origin = "Origin Period", dev = "Development Period", value = "Amount"
)
})
# Name the nested elements (2nd level) of the list
names(type_list) <- unique_types
type_list
})
# Name the elements of the list (1st level)
names(triangle_list) <- unique_portfolios
triangle_list
triangle_list <- lapply(unique_portfolios, function(i) {
datamat_cur <- datamat[datamat$`Portfolio Name` == i,]  # Assuming datamat is now a data.table
type_list <- lapply(unique_types, function(j) {
datamat_type <- datamat_cur[datamat_cur$`Type of Amount` == j,]
if (cumorinc) {
cum2incr(
as.triangle(
as.data.frame(datamat_type),
origin = "Origin Period", dev = "Development Period", value = "Amount"
)
)
}else{
as.triangle(
as.data.frame(datamat_type),
origin = "Origin Period", dev = "Development Period", value = "Amount"
)
}
})
# Name the nested elements (2nd level) of the list
names(type_list) <- unique_types
type_list
})
cumorinc <-T
cumorinc
triangle_list <- lapply(unique_portfolios, function(i) {
datamat_cur <- datamat[datamat$`Portfolio Name` == i,]  # Assuming datamat is now a data.table
type_list <- lapply(unique_types, function(j) {
datamat_type <- datamat_cur[datamat_cur$`Type of Amount` == j,]
if (cumorinc) {
cum2incr(
as.triangle(
as.data.frame(datamat_type),
origin = "Origin Period", dev = "Development Period", value = "Amount"
)
)
}else{
as.triangle(
as.data.frame(datamat_type),
origin = "Origin Period", dev = "Development Period", value = "Amount"
)
}
})
# Name the nested elements (2nd level) of the list
names(type_list) <- unique_types
type_list
})
triangle_list
cumorinc <- F
triangle_list <- lapply(unique_portfolios, function(i) {
datamat_cur <- datamat[datamat$`Portfolio Name` == i,]  # Assuming datamat is now a data.table
type_list <- lapply(unique_types, function(j) {
datamat_type <- datamat_cur[datamat_cur$`Type of Amount` == j,]
if (cumorinc) {
cum2incr(
as.triangle(
as.data.frame(datamat_type),
origin = "Origin Period", dev = "Development Period", value = "Amount"
)
)
}else{
as.triangle(
as.data.frame(datamat_type),
origin = "Origin Period", dev = "Development Period", value = "Amount"
)
}
})
# Name the nested elements (2nd level) of the list
names(type_list) <- unique_types
type_list
})
attachment::att_amend_desc()
run_app()
data_res
data_res_2
create_triangle_fromdata(datamat = data_res, cumorinc = T)
create_triangle_fromdata(datamat = data_res_2, cumorinc = T)
dummy_res <- data_res
"Case Reserves" %in% unique(dummy_res$`Type of Amount`)
!("Case Reserves" %in% unique(dummy_res$`Type of Amount`))
#'       Using the function "remove_duplicates_by_sum()", we summarize the duplicates
#'       and remove the duplicated rows.
#' 4. If Case Reserves are not given in the data table, then we need to add it
#'      "manually" by calculating:
#'      Case Reserves = Claims Reported excl. ACR - Claims Paid
#'
#' @param datamat Data frame/table that has already the right number and type of
#'                of columns but does not satisfy the/one of the 4 conditions above.
#' @return datamat, in the template format needed by SPIRE
#' @export
template_prep <- function(datamat){
# Development Period should start with 0 and therefore if there is no 0 element
## we need to shift it:
if ( min(as.numeric(datamat$`Development Period`)) >= 3 &&
unique(datamat$`Development Period frequency`) == "Quarterly") {
datamat$`Development Period` <- as.numeric(datamat$`Development Period`) - 3
}else if ( min(as.numeric(datamat$`Development Period`)) >= 1 &&
unique(datamat$`Development Period frequency`) == "Annual") {
datamat$`Development Period` <- as.numeric(datamat$`Development Period`) - 1
}else if ( min(as.numeric(datamat$`Development Period`)) >= 1 &&
unique(datamat$`Development Period frequency`) == "Monthly") {
datamat$`Development Period` <- as.numeric(datamat$`Development Period`) - 1
}else if ( min(as.numeric(datamat$`Development Period`)) >= 6 &&
unique(datamat$`Development Period frequency`) == "Half-yearly") {
datamat$`Development Period` <- as.numeric(datamat$`Development Period`) - 6
}
# If the Origin Period has only 4 digits, we add "01" to it
## We check only the first one, as this should be sufficient for the rest
if (as.numeric(datamat$`Origin Period`[1]) < 100000) {
datamat$`Origin Period` <- as.numeric(paste0(datamat$`Origin Period`, "01"))
}
# Make Uniqueness of the rows save:
datamat <- remove_duplicates_bysum(df_to_manipulate = datamat)
# Calculation of Claims Reported if there is no Claims Reported in Type of Amount:
# unique_toas <- unique(datamat$`Type of Amount`)
# if (!("Case Reserves" %in% unique_toas) &&
#     (("Claims Reported excl. ACR" %in% unique_toas) || ("Claims Reported incl. ACR" %in% unique_toas))) {
#   # Check whether PAID values are given or not:
#   if ("Claims Paid" %in% unique_toas) {
#
#   }else{
#
#   }
#
# }
return(datamat)
}
# Prepare the SPIRE Template and save it to the reactive list
dummy_res <- template_prep(dummy_res)
# Create triangles out of the given data table
triangle_list <- create_triangle_fromdata(datamat = dummy_res, cumorinc = T)
nested_list <- triangle_list
nested_list
names(nested_list)
i <- names(nested_list)
i <- i[1]
portfolio_list
# Access the nested list for the current Portfolio Name
portfolio_list <- nested_list[[i]]
portfolio_list
# Access the 'Reported' and 'Paid' triangles (assuming they are named 'Reported' and 'Paid')
grepl("Reported", names(portfolio_list))
reported_triangle <- portfolio_list[[grepl("Reported", names(portfolio_list))]]
grepl("Reported", names(portfolio_list))
which(grepl("Reported", names(portfolio_list))==T)[1]
# Access the 'Reported' and 'Paid' triangles
reported_triangle <- portfolio_list[[which(grepl("Reported", names(portfolio_list)) == T)[1]]]
paid_triangle <- portfolio_list[[which(grepl("Paid", names(portfolio_list)) == T)[1]]]
reported_triangle
paid_triangle
!is.null(reported_triangle)
!is.null(paid_triangle)
i
# Check if both triangles exist for the current Portfolio Name
if(!is.null(reported_triangle)) {
if (!is.null(paid_triangle)) {
# Ensure the triangles have matching dimensions
if(all(dim(reported_triangle) == dim(paid_triangle))) {
# Subtract the 'Paid' triangle from the 'Reported' triangle
case_reserves <- reported_triangle - paid_triangle
# Add the "Case Reserves" to the current portfolio list:
portfolio_list[["Case Reserves"]] <- case_reserves
# Store the difference triangle in difference_list under the current Portfolio Name
nested_list[[i]] <- portfolio_list
} else {
warning(paste("Mismatched dimensions for Portfolio Name:", i))
}
}else{
# In this case we set the Case reserves and the Reported Values equal:
case_reserves <- reported_triangle
# Add the "Case Reserves" to the current portfolio list:
portfolio_list[["Case Reserves"]] <- case_reserves
# Store the difference triangle in difference_list under the current Portfolio Name
nested_list[[i]] <- portfolio_list
}
} else {
warning(paste("Missing Reported Values for Portfolio Name:", i))
}
reported_triangle
dim(reported_triangle)
dim(paid_triangle)
# Iterate through each Portfolio Name in nested_list
for (i in names(nested_list)) {
# Access the nested list for the current Portfolio Name
portfolio_list <- nested_list[[i]]
# Access the 'Reported' and 'Paid' triangles
reported_triangle <- portfolio_list[[which(grepl("Reported", names(portfolio_list)) == T)[1]]]
paid_triangle <- portfolio_list[[which(grepl("Paid", names(portfolio_list)) == T)[1]]]
# Check if both triangles exist for the current Portfolio Name
if(!is.null(reported_triangle)) {
if (!is.null(paid_triangle)) {
# Ensure the triangles have matching dimensions
if(all(dim(reported_triangle) == dim(paid_triangle))) {
# Subtract the 'Paid' triangle from the 'Reported' triangle
case_reserves <- reported_triangle - paid_triangle
# Add the "Case Reserves" to the current portfolio list:
portfolio_list[["Case Reserves"]] <- case_reserves
# Store the difference triangle in difference_list under the current Portfolio Name
nested_list[[i]] <- portfolio_list
} else {
warning(paste("Mismatched dimensions for Portfolio Name:", i))
}
}else{
# In this case we set the Case reserves and the Reported Values equal:
case_reserves <- reported_triangle
# Add the "Case Reserves" to the current portfolio list:
portfolio_list[["Case Reserves"]] <- case_reserves
# Store the difference triangle in difference_list under the current Portfolio Name
nested_list[[i]] <- portfolio_list
}
} else {
warning(paste("Missing Reported Values for Portfolio Name:", i))
}
}
warnings()
# Check if both triangles exist for the current Portfolio Name
if(!is.null(reported_triangle)) {
if (!is.null(paid_triangle)) {
print(paste0(dim(reported_triangle)," vs. ", dim(paid_triangle)))
# Ensure the triangles have matching dimensions
if(all(dim(reported_triangle) == dim(paid_triangle))) {
# Subtract the 'Paid' triangle from the 'Reported' triangle
case_reserves <- reported_triangle - paid_triangle
# Add the "Case Reserves" to the current portfolio list:
portfolio_list[["Case Reserves"]] <- case_reserves
# Store the difference triangle in difference_list under the current Portfolio Name
nested_list[[i]] <- portfolio_list
} else {
warning(paste("Mismatched dimensions for Portfolio Name:", i))
}
}else{
# In this case we set the Case reserves and the Reported Values equal:
case_reserves <- reported_triangle
# Add the "Case Reserves" to the current portfolio list:
portfolio_list[["Case Reserves"]] <- case_reserves
# Store the difference triangle in difference_list under the current Portfolio Name
nested_list[[i]] <- portfolio_list
}
} else {
warning(paste("Missing Reported Values for Portfolio Name:", i))
}
# Iterate through each Portfolio Name in nested_list
for (i in names(nested_list)) {
# Access the nested list for the current Portfolio Name
portfolio_list <- nested_list[[i]]
# Access the 'Reported' and 'Paid' triangles
reported_triangle <- portfolio_list[[which(grepl("Reported", names(portfolio_list)) == T)[1]]]
paid_triangle <- portfolio_list[[which(grepl("Paid", names(portfolio_list)) == T)[1]]]
# Check if both triangles exist for the current Portfolio Name
if(!is.null(reported_triangle)) {
if (!is.null(paid_triangle)) {
print(paste0(dim(reported_triangle)," vs. ", dim(paid_triangle)))
# Ensure the triangles have matching dimensions
if(all(dim(reported_triangle) == dim(paid_triangle))) {
# Subtract the 'Paid' triangle from the 'Reported' triangle
case_reserves <- reported_triangle - paid_triangle
# Add the "Case Reserves" to the current portfolio list:
portfolio_list[["Case Reserves"]] <- case_reserves
# Store the difference triangle in difference_list under the current Portfolio Name
nested_list[[i]] <- portfolio_list
} else {
warning(paste("Mismatched dimensions for Portfolio Name:", i))
}
}else{
# In this case we set the Case reserves and the Reported Values equal:
case_reserves <- reported_triangle
# Add the "Case Reserves" to the current portfolio list:
portfolio_list[["Case Reserves"]] <- case_reserves
# Store the difference triangle in difference_list under the current Portfolio Name
nested_list[[i]] <- portfolio_list
}
} else {
warning(paste("Missing Reported Values for Portfolio Name:", i))
}
}
names(portfolio_list)
which(grepl("Paid", names(portfolio_list)) == T)[1]
portfolio_list[[which(grepl("Paid", names(portfolio_list)) == T)[1]]]
View(reported_triangle)
View(paid_triangle)
class(reported_triangle)
class(reported_triangle) <- "matrix"
class(paid_triangle)
class(paid_triangle) <- "matrix"
dim(reported_triangle)
dim(paid_triangle)
reported_triangle
paid_triangle
?C()
datamat
# Now create the biggest possible data frame using information comming from datamat
min(datamat$`Origin Period`):max(datamat$`Origin Period`)
length(min(datamat$`Origin Period`):max(datamat$`Origin Period`))
max(datamat$`Origin Period`) - min(datamat$`Origin Period`) + 1
as.numeric(max(datamat$`Origin Period`)) - as.numeric(min(datamat$`Origin Period`)) + 1
as.nuermic(max(datamat$`Development Period`))
max(datamat$`Development Period`)
as.numeric(max(datamat$`Development Period`))
max(as.numeric(datamat$`Origin Period`))
as.numeric(max(datamat$`Development Period`))
unique(datamat)
unique(datamat$`Development Period`)
max(as.numeric(datamat$`Development Period`))
max(as.numeric(datamat$`Development Period`)) - min(as.numeric(datamat$`Development Period`))
sorted_dev_per <- sorted(as.numeric(datamat$`Development Period`))
sorted_dev_per <- sort(as.numeric(datamat$`Development Period`))
sorted_dev_per
sort(unique(as.numeric(datamat$`Development Period`)))
attachment::att_amend_desc()
attachment::att_amend_desc()
run_app()
attachment::att_amend_desc()
run_app()
data_res
prep_df <- data_res
# Prepare the SPIRE Template and save it to the reactive list
prep_df <- template_prep(prep_df)
# Prepare list for potential triangle creation:
triangle_list <- NULL
# Transform the data to incremental values, if it is given as cumulative ones:
print(input$MU_fileupload_cumulativeformat)
!("Case Reserves" %in% unique(prep_df$`Type of Amount`))
# If the triangle_list was not yet created, then we do the following:
print(triangle_list)
is.null(triangle_list)
# Create triangles out of the given data table
triangle_list <- create_triangle_fromdata(datamat = prep_df, cumorinc = T)
triangle_list <-
create_triangle_fromdata(datamat = prep_df,
cumorinc = F)
triangle_list
nested_list <- triangle_list
# Iterate through each Portfolio Name in nested_list
for (i in names(nested_list)) {
# Access the nested list for the current Portfolio Name
portfolio_list <- nested_list[[i]]
# Access the 'Reported' and 'Paid' triangles
reported_triangle <- portfolio_list[[which(grepl("Reported", names(portfolio_list)) == T)[1]]]
paid_triangle <- portfolio_list[[which(grepl("Paid", names(portfolio_list)) == T)[1]]]
# Check if both triangles exist for the current Portfolio Name
if(!is.null(reported_triangle)) {
if (!is.null(paid_triangle)) {
print(paste0(dim(reported_triangle)," vs. ", dim(paid_triangle)))
# Ensure the triangles have matching dimensions
if (all(dim(reported_triangle) == dim(paid_triangle))) {
# Subtract the 'Paid' triangle from the 'Reported' triangle
case_reserves <- reported_triangle - paid_triangle
# Add the "Case Reserves" to the current portfolio list:
portfolio_list[["Case Reserves"]] <- case_reserves
# Store the difference triangle in difference_list under the current Portfolio Name
nested_list[[i]] <- portfolio_list
} else {
# This case should never happen as we predefine the size of the
#     nested element spaces in "CreateTriangles_from_DataTable.R"
## --> If you come to this place, then
warning(paste("Mismatched dimensions for Portfolio Name:", i))
}
}else{
# In this case we set the Case reserves and the Reported Values equal:
case_reserves <- reported_triangle
# Add the "Case Reserves" to the current portfolio list:
portfolio_list[["Case Reserves"]] <- case_reserves
# Store the difference triangle in difference_list under the current Portfolio Name
nested_list[[i]] <- portfolio_list
}
} else {
warning(paste("Missing Reported Values for Portfolio Name:", i))
}
# Still need to create the additional df which will be added in the end
## to the final data frame:
additional_casereserves_df <- c()
# --> This needs to be adapted at the end!
return(list(nested_list, additional_casereserves_df))
}
nested_list
nested_list
datamat <- data_res
# First convert the data columns "Origin Period", "Development Period", "Amount"
## to needed numeric form:
datamat[, "Amount"] <- round(as.numeric(datamat[, "Amount" ]), digits = 2)
unique_portfolios <- unique(datamat$`Portfolio Name`)
unique_types <- unique(datamat$`Type of Amount`)
unique_portfolios
unique_types
rowlength <- max(as.numeric(datamat$`Origin Period`)) - min(as.numeric(datamat$`Origin Period`)) + 1
rowlength
sorted_dev_per <- sort(unique(as.numeric(datamat$`Development Period`)))
sorted_dev_per
datamat <- prep_df
# First convert the data columns "Origin Period", "Development Period", "Amount"
## to needed numeric form:
datamat[, "Amount"] <- round(as.numeric(datamat[, "Amount" ]), digits = 2)
unique_portfolios <- unique(datamat$`Portfolio Name`)
unique_types <- unique(datamat$`Type of Amount`)
rowlength <- max(as.numeric(datamat$`Origin Period`)) - min(as.numeric(datamat$`Origin Period`)) + 1
sorted_dev_per <- sort(unique(as.numeric(datamat$`Development Period`)))
sorted_dev_per
columnslength <-
max(as.numeric(datamat$`Development Period`)) - min(as.numeric(datamat$`Development Period`))
rowlength
length(min(as.numeric(datamat$`Origin Period`)):max(as.numeric(datamat$`Origin Period`)))
rowlength <- length(min(as.numeric(datamat$`Origin Period`)):max(as.numeric(datamat$`Origin Period`)))
rowlength
rowlength
length(min(as.numeric(datamat$`Origin Period`)):max(as.numeric(datamat$`Origin Period`)))
rowlength <- length(max(as.numeric(datamat$`Origin Period`))-min(as.numeric(datamat$`Origin Period`)) + 1)
rowlength
rowlength <- length(max(as.numeric(datamat$`Origin Period`)) - min(as.numeric(datamat$`Origin Period`)) + 1)
rowlength
rowlength <- max(as.numeric(datamat$`Origin Period`)) - min(as.numeric(datamat$`Origin Period`) + 1)
rowlength
max(as.numeric(datamat$`Origin Period`))
min(as.numeric(datamat$`Origin Period`)
)
rowlength <- max(as.numeric(datamat$`Origin Period`)) - min(as.numeric(datamat$`Origin Period`)) + 1
rowlength
rowlength <- max(as.numeric(substr(datamat$`Origin Period`,1,4))) - min(as.numeric(substr(datamat$`Origin Period`, 1,4))) + 1
rowlength
sorted_dev_per <- sort(unique(as.numeric(datamat$`Development Period`)))
sorted_dev_per
0:sorted_dev_per[length(sorted_dev_per)]
seq(0,sorted_dev_per[length(sorted_dev_per)], 3)
# We take always the 2nd element, as the first one will be 0 in each case (Annual, Half-yearly, ...)!
length(seq(0,sorted_dev_per[length(sorted_dev_per)], sorted_dev_per[2]) )
95*3 - 3
# We take always the 2nd element, as the first one will be 0 in each case (Annual, Half-yearly, ...)!
collength <- length(seq(0,sorted_dev_per[length(sorted_dev_per)], sorted_dev_per[2]) )
prototype_df <- as.data.frame(as.matrix(rep(NA, rowlength*collength)))
prototype_df <- as.data.frame(as.matrix(rep(NA, rowlength*collength), ncol = collength, nrow = rowlength))
prototype_df
prototype_df <- as.data.frame(as.matrix(rep(NA, rowlength*collength), ncol = collength, nrow = rowlength))
prototype_df
prototype_df <- as.data.frame(matrix(rep(NA, rowlength*collength), ncol = collength, nrow = rowlength))
prototype_df
colnames(prototype_df) <- seq(0,sorted_dev_per[length(sorted_dev_per)], sorted_dev_per[2])
min(as.numeric(datamat$`Origin Period`))
rownames(prototype_df) <- seq(min(as.numeric(datamat$`Origin Period`)), max(as.numeric(datamat$`Origin Period`)), 100)
prototype_df
attachment::att_amend_desc()
run_app()
library(shinyWidgets)
?pickerInput
colnames(perp_df)
colnames(prep_df)
attachment::att_amend_desc()
run_app()
attachment::att_amend_desc()
run_app()
?textInput
attachment::att_amend_desc()
?textInput
run_app()
attachment::att_amend_desc()
run_app()
attachment::att_amend_desc()
run_app()
attachment::att_amend_desc()
run_app()
attachment::att_amend_desc()
run_app()
data_res
attachment::att_amend_desc()
run_app()
